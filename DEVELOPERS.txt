------------- How is image/icon/cover passed from the OPML item to a track -------------

When a $url from an OPML item is added to current playlist, a $track object is created 
and its image is obtained by calling handlerForUrl($url)->getMetadataFor($url). 
If this protocol handler is HTTP, it needs to find the image just by using this $url, 
there is no other information. 

XMLBrowser(s), when adding the url to the playlist, call setRemoteMetadata which caches
the OPML items's image link as "remote_image_$url". Inside setRemoteMetadata, the $url's
protocol handler will be called with a method cacheImage(class, url, image, prefix). 
That method can either return true and then the "remote_image_$url" will be cached or it 
can also do its own caching and return false. When remote_image_$url is cached, it is 
used getMetadataFor() as one of the image sources. 

Now, when playing the $track, if scanUrl() points to Slim::Utils::Scanner::Remote::ScanURL() 
and if there are redirections, the $track->url is modified to $newurl which will then be 
used in further getMetadataFor calls. As this $newurl has no image's link entry in the 
cache, the "remote_entry_$url" is copied upon each redirection to "remote_image_$newurl" 
during the scan. Ultimately, when the actual image is cached (not the link), there will be
an artwork cache entry that getMetadataFor() will use. 

--------------------------------- How scanUrl works ------------------------------------

For HTTP(S) protocol handler, the scanUrl calls Slim::Utils::Scanner::Remote::scanURL when
a track starts to play to acquire all necessary informations. The scanUrl is called with 
the $url to scan and a $song object in the $args. 

That $song has a $track object that is created from the original $url set when OPML item 
is added in the playlist. When scanning $url, the Slim::Utils::Scanner::Remote::scanURL
creates a new $track object everytime the final URI returned by the GET is different from 
the $url argument. This happens on HTTP redirection and/or if the $url argument differs 
from $args->{'song'}->track->url. When it finally returns, scanUrl provides a new $track
that replaces the current one in the $song object and in the playlist.

------------------------ Thin Protocol Hander (e.g. podcast) -----------------------------

A thing protocol handler which simply encapsulate HTTPS(s) and mostly encapsulate http(s) 
urls into something like "<myph>://http://<$url>". Typically, the scanUrl de-encapsulate the 
$url into the HTTP(S) one and then relies on normal handling, but there are a few catches
as we want to benefit from all HTTP(S) methods but still overload some, making sure our 
protocol handler is still called after we have de-encapsulated urls.

1- When a $track object has changed after scanUrl, the required protocol handler is 
re-evaluated and replaced by what matches the actual $track->url (there are many protocol 
handlers but that's too difficult to describe here). That means that the thin protocol 
handler would loose control if the $track->url has been reset to HTTP(S). To avoid that, an
optional <myph>::songHandler() method is called to see if the thin protocol handler still 
wants control.

3- Now, not every thin protocol handler's methods will be called after this scan because some
portion of LMS will always call handlerForUrl($track->url) and not use the protocol handler
that is stored inside the $song object. As of 8.2, we are trying to limit these but there is
still work to do.
	
NB: Before calling scanUrl, do not try to replace manually the $args->{'song'}->{'track'}->url 
with the de-encapsulated $url that is passed an argument, that will mess the whole scanning 
process

----------------------------------- HTTP methods -----------------------------------------
The constructors of Slim::Networking::SimpleAsyncHTTP and Slim::Networking::Async::HTTP have
two new keys in their hash argument 

 - 'options': set parameters for underlying socket object. For example, to change SSL
		options => {
          SSL_cipher_list => 'DEFAULT:!DH',
          SSL_verify_mode => Net::SSLeay::VERIFY_NONE }
		}
 - 'socks': use a socks proxy to tunnel the request (see SOCKS.TXT)
		socks => { 
			ProxyAddr => '192.168.0.1',	# can also be a FQDN
			ProxyPort => 1080, 			# optional, 1080 by default
			Username => 'user',			# only for socks5
			Password => 'password',		# only for socks5
		}	
		
   Slim::Networking::Async::HTTP->new( { 
		options => {
            SSL_cipher_list => 'DEFAULT:!DH',
            SSL_verify_mode => Net::SSLeay::VERIFY_NONE
		},
		socks => { 
			ProxyAddr => '192.168.0.1',
			ProxyPort => 1080, 			
		}
	} );
